//package com.firnice.zuti.collection;
//
//public class Test {
//
//    检验参数
//
//    开屏配置-库存安全
//
//    开屏配置-规则缓存有效期
//
//    流量比例开关
//
//    foodie 特殊处理
//
//    缓存获取计划列表
//
//    for(开屏规则有效期){
//
//    ​	变量定义
//
//    ​	if（计划为空）{
//
//    ​		continue
//
//    ​	}
//
//    ​	for（计划）{
//
//    ​		判断是否有pmp
//
//    ​	}
//
//    ​	for（计划）{
//
//    ​		第一轮筛选
//
//    ​	}
//
//    ​
//
//    ​	for（第一轮筛选后的计划）{
//
//    ​		过滤共享库存是否合法, 上一个循环会有部分遗漏, 本次循环补漏
//    ​    	同时对于有PMP计划的情况, 保证其余计划不在目标列表中, 但在请求优先级中加入
//
//    ​	}
//
//    ​	if（目标计划为空）{
//
//    ​		continue
//
//    ​	}
//
//    ​	for（目标计划）{
//
//    ​		if(直投){
//
//    ​			设置创意信息
//
//    ​		}
//
//    ​		if（PMP）{
//    ​				notPdblist +1
//
//    ​		}else if(PDB){
//
//    ​			pdbList +1
//
//    ​		}default{
//
//    ​			noPdbList+1
//
//    ​		}
//
//        ​}
//
//​		if（没有pdb）{
//
//​			if(有pmp){
//
//​				请求优先级&展示优先级+1
//
//​			}else{
//
//​				没有pmp&pdb
//
//​				// 在没有PDB,也没有PMP的targetPlanList中计算所有可能的计划列表
//
//​				for（所有可能的计划列表）{
//
//​					是否存在与该设备上一次相同的展示优先级
//
//​					获取上次展示优先级
//
//​				}
//
//​				if(和上次展示优先级相同){
//
//​					使用sdk传来的
//
//​				}else{
//
//​					当前计算的下次展示优先级
//
//​				}
//
//​			}
//
//​		}else{
//            //有PDB
//            //计算所有非PDB计划的总概率
//            for(可能包含虚拟计划、概率为0的兜底计划、其余正常的pdb计划){
//
//                if(先获取所有PD和RTB的可能的计划列表 为空){
//                    // 非PDB如果为空,则只需要添加PDB的计划优先级的可能性
//                    // 排除虚拟计划
//                }else{
//                    // 非PDB计划如果不为空,则类似组合计数里的乘法原理,累计可能性
//                    for(先获取所有PD和RTB的可能的计划列表){
//                        //所有可能的展示优先级
//                    }
//
//                }
//
//            }
//
//            // 标识是否存在和上一次展示优先级一样的优先级列表
//            for (所有可能的展示优先级){
//
//            }
//
//            if (与上次展示优先级lastExposurePriorityList对比) {
//                // 如果存在,使用sdk传过来的上次展示优先级
//            } else {
//                // 如果不存在,使用实时计算的下次展示优先级作为本次展示优先级
//            }
//
//        }
//        //将请求优先级中最高的优先级提为第一优先级
//        for(下次请求优先级列表){
//            // 将排序后的第一个元素置为优先级为1
//        }
//
//        for(下次请求优先级列表){
//            // 若有另一个与当前最高优先级相同优先级的渠道，说明其是概率为0的渠道
//        }
//
//        for(下次请求优先级列表){
//            // 计算最终的请求优先级
//        }
//
//        //设置结果
//
//    ​
//
//​	}
//
//}
//
//
//
//}
